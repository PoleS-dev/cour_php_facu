<?php 
namespace App;

?>
<h1>Cour sur l'heritage des classes en PHP</h1>

<h3>H√©ritage c'est quoi ? </h3>


<p>L'h√©ritage permet √† une classe d'h√©riter des propri√©t√©s et m√©thodes d'une autre classe.</p>


<h4>exemple : </h4>


<?php 


class Animal {

    public function respirer() : void {

        echo "je respire dans l'air <br>";
}

}




class Chien extends Animal {

public function aboyer() : void {       
    echo "ouaf ouaf <br>";
}

}

class Chat extends Animal {

    public function miauler() : void {

        echo "miaou <br>";

    }
}
$chien1=new Chien();
$chien1->respirer();
$chien1->aboyer();

?>

<h2>redefinir une m√©thode (Override)</h2>

<?php 

class Poisson extends Animal{

    // cas  1  redefinition complete de la m√©thode ( on ecrase la version parente que sur la class Poison)
    
    public function respirer() : void {

        echo "je respire dans l'eau <br>";
    }
    
}

class Reptil extends Animal{

    // cas  2  on utlise le parent:: respirer() pour remplacer la version du parent 
    
    public function respirer() : void {
        // on appelle d'abord la methode du parent (Animal)
        parent::respirer();
        // puis on ajoute une phrase personalis√©e
        echo " et dans l'eau !   <br>";
  
}
}

// quand on veut conserver la logique du parent et l'enrichire : ajouter un comportement par exemple. on utilise parent::

// quand on veut totalement changer la logique du parent : on ecrase la version parente on utilise pas parent::

    
$reptil1=new Reptil();
$reptil1->respirer();


class Vehicule 
{

    public string $marque="sans nom";
    protected int $vitesse=0;
    private string $moteur="sans moteur";

    

    public function getMoteur() : string {
        return $this->moteur;
    }

    public function setMoteur(string $moteur) :string {
        return $this->moteur = $moteur;
    }

    public function accelerer() : void {

        $this->vitesse += 10;
        echo "Vitesse actuelle : {$this->vitesse} km/h<br>";

    }
}

class Voiture extends Vehicule {


    public function turbo() : void {
 

        $this->vitesse += 50;
        echo "Vitesse actuelle apres turbo : {$this->vitesse} km/h<br>";
    
}

public function creerMoteur(string $moteur)  {
          return $this->setMoteur($moteur);
}

public function afficherMoteur() : void {
    echo "moteur : {$this->getMoteur()}<br>";// comme moteur est en private  on doit passer par le getter


}
}

$voiture1 = new Voiture();
echo $voiture1->creerMoteur("essence");
$voiture1->accelerer();
$voiture1->turbo();

?>
<h2> abstract class</h2>

<p> une class abstraite ne peut pas √™tre instanci√©e directement.</p>
<p>Elle sert de mod√®le aux classes qui l'√©tendent. Elle peut contenir des m√©thodes abstraites (√† d√©finir obligatoirement)</p>

<p>elle sert de model de base et peut contenir :</p>

<ul>
    <li>des methodes normales avec du code </li>
    <li>des methodes abstraites sans corps</li>
</ul>



<?php 

abstract class Animals {

    protected string $nom;
 
    public function __construct(string $nom) {

        $this->nom = $nom;

    }
 
    // M√©thode abstraite : aucune impl√©mentation ici

    abstract public function crier();
 
    // M√©thode normale : peut √™tre utilis√©e telle quelle

    public function sePresenter() {

        echo "Je suis un animal nomm√© $this->nom<br>";
     

    }

}
 
 class Chiens extends Animals {

      public function crier() {

        echo "Ouaf Ouaf üê∂<br>";

    }

}




 
$rex = new Chiens("Rex");

$rex->sePresenter();

$rex->crier();





?>

<h2>Utilisation de final</h2>

<p>La mot-cl√© final emp√™che la surcharge (redefinition) d'une m√©thode.</p>
<p>Elle peut √™tre utilis√©e sur des classes, des m√©thodes, ou des propri√©t√©s.</p>
<p> Si au d√©but d"une class il y a final, faire un heritage de cette class est impossible, c'est la classe final sans enfants possible</p>

<p>

    final class MaclassFinal, creation de la class final sans enfants possible
</p>

<p>

    class ClassEnfant extends MaclassFinal, on ne peut pas faire de heritage de la class final, cela va donn√© une erreur
</p>

<p>
    quand on d√©clare final dans une methode, les classes qui h√©rite ne pourront pas redefinir la methode 
</p>


<p>pourquoi utiliser final sur une methode ? </p>

<ul>
    <li> Pour verrouiller un comportement spa√©cifique qui ne doit pas √™tre modifi√©</li>
    <li>Pour garantir la s√©curit√© des donn√©es</li>
    <li>Pour eviter les erreur et les abus d'heritage</li>
</ul>

<?php 

class Employe
{
    protected string $nom;
 
    public function __construct(string $nom)
    {
        $this->nom = $nom;
    }
 
    final public function travailler()
    {
        echo "$this->nom travaille s√©rieusement.<br>";
    }
}
 
class Manager extends Employe
{
    // ‚ùå ERREUR ! On ne peut pas red√©finir une m√©thode final
    /*
    public function travailler() {
        echo "$this->nom travaille en dirigeant l'√©quipe.<br>";
    }
    */
    public function diriger()
    {
        echo "$this->nom dirige une √©quipe.<br>";
    }
}
 
$m = new Manager("Sophie");
$m->travailler(); // fonctionne
$m->diriger();



?> 


<h2> trait</h2>

// Un trait en PHP est une sorte de bloc de code r√©utilisable.
// Il permet de partager des m√©thodes ou propri√©t√©s entre plusieurs classes,
// sans avoir √† utiliser l'h√©ritage (extends).
//
// Contrairement √† une classe, un trait ne peut pas √™tre instanci√© directement.
// On l‚Äôutilise dans une classe avec le mot-cl√© "use".
//
// C‚Äôest tr√®s utile quand plusieurs classes ont des comportements identiques,
// mais qu‚Äôelles n‚Äôont pas de lien logique pour h√©riter d‚Äôune m√™me classe.
//
// Exemple :
//
// trait Logger {
//     public function log($message) {
//         echo "[LOG] " . $message;
//     }
// }
//
// class Utilisateur {
//     use Logger;
// }
//
// $u = new Utilisateur();
// $u->log("Utilisateur connect√©.");  // Affiche : [LOG] Utilisateur connect√©.
//
// Ce syst√®me permet de factoriser du code sans casser la hi√©rarchie objet.









 









    




    






        